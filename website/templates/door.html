<!DOCTYPE html>
<html>
<head>
    <title>{{ _('Door') }} {{door}} - {{ _('Interactive Sudoku') }}</title>
    <style>
        /* Language switcher styles */
        .language-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .language-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .language-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }
        
        .language-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }
        
        .language-btn:active {
            transform: translateY(0);
        }
        
        .language-icon {
            font-size: 18px;
        }
        
        .dropdown-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        
        .language-dropdown.active .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .language-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            min-width: 150px;
        }
        
        .language-dropdown.active .language-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .language-option {
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #333;
            text-decoration: none;
            font-weight: 500;
        }
        
        .language-option:hover {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        }
        
        .language-option.active {
            background: linear-gradient(135deg, #667eea25 0%, #764ba225 100%);
            color: #667eea;
        }
        
        .flag-icon {
            font-size: 20px;
        }
        
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .sudoku-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }
        .sudoku {
            border-collapse: separate;
            border-spacing: 0;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #000000 !important;        /* Thick outer border */
        }
        .diagonal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
        }
        .sudoku td {
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            position: relative;
            box-sizing: border-box;
            border-top: 1px solid #bbb;        /* Thin default grid line */
            border-left: 1px solid #bbb;
            border-right: 0;
            border-bottom: 0;
        }
        /* Remove top border for first row (leave for table) */
        .sudoku tr:first-child td {
            border-top: none;
        }
        /* Remove left border for first column (leave for table) */
        .sudoku td:first-child {
            border-left: none;
        }
        /* Thick top borders after rows 3 and 6 (for box separators) */
        .sudoku tr:nth-child(4) td,
        .sudoku tr:nth-child(7) td {
            border-top: 2px solid #000;
        }
        /* Thick left borders after columns 3 and 6 (for box separators) */
        .sudoku td:nth-child(4),
        .sudoku td:nth-child(7) {
            border-left: 2px solid #000;
        }
        /* No bottom border for last row (table border only) */
        .sudoku tr:last-child td {
            border-bottom: none;
        }
        /* No right border for last column (table border only) */
        .sudoku td:last-child {
            border-right: none;
        }
        .sudoku td input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            outline: none;
            background-color: #fffef0;
        }
        .sudoku td .notes {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.7rem;
            font-weight: normal;
            color: #666;
            line-height: 1.1;
            pointer-events: none;
            max-width: 40px;
            word-wrap: break-word;
        }

        /* Remove browser focus outline/shadow and hide the blinking caret when an input is focused
           This removes the blue blinking line on focused inputs while preserving the selected-cell
           outline which is applied to the parent <td>. */
        .sudoku td input:focus {
            outline: none !important;
            box-shadow: none !important;
            -webkit-box-shadow: none !important;
            -webkit-appearance: none !important;
            caret-color: transparent !important; /* hides blinking caret */
            -webkit-tap-highlight-color: transparent !important; /* mobile tap highlight */
        }

        /* Layer 1: Base background - LOWEST PRIORITY */
        /* Default input background is set above */

        /* Layer 2: Prefilled cells - overrides background, borders show through */
        .sudoku td.prefilled {
            background-color: #e8e8e8;
            color: inherit;
            cursor: pointer;
        }
        .sudoku td.prefilled:focus {
            outline: none; /* Remove default outline, we use selected-cell class */
        }

        /* Layer 3: Special field colors - override prefilled cells, borders show through */
        .sudoku td.diagonal-cell {
            background-color: #e8f4f8 !important;
            color: inherit;
        }
        .sudoku td.windoku-cell {
            background-color: #e3f2fd !important;
            color: inherit;
        }
        .sudoku td.asterisk-cell {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.even-cell {
            background-color: #c8e6c9 !important;
            color: inherit;
        }
        .sudoku td.odd-cell {
            background-color: #ffccbc !important;
            color: inherit;
        }
        .sudoku td.magic-square-cell {
            background-color: #c8efca !important;
            color: inherit;
        }
        .sudoku td.center-dot-cell {
            background-color: #ffe0b2 !important;
            color: inherit;
        }
        .sudoku td.thermo-cell {
            background-color: #e1f5fe !important;
            color: inherit;
        }
        .sudoku td.arrow-circle {
            background-color: #fff9c4 !important;
            color: inherit;
            border-radius: 50%;
        }
        .sudoku td.arrow-cell {
            background-color: #fffde7 !important;
            color: inherit;
        }
        .sudoku td.renban-cell {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-0 {
            background-color: #ffebee !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-1 {
            background-color: #e8f5e9 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-2 {
            background-color: #e3f2fd !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-3 {
            background-color: #fff3e0 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-4 {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-5 {
            background-color: #fce4ec !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-6 {
            background-color: #e0f2f1 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-7 {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-8 {
            background-color: #e1f5fe !important;
            color: inherit;
        }
        .sudoku td.whisper-cell {
            background-color: #e1bee7 !important;
            color: inherit;
        }
        .sudoku td.chain-corner-cell {
            background-color: #ffecb3 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-0 {
            background-color: #c5e1a5 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-1 {
            background-color: #b3e5fc !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-2 {
            background-color: #ffe0b2 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-3 {
            background-color: #f8bbd0 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-4 {
            background-color: #d1c4e9 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-5 {
            background-color: #ffccbc !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-6 {
            background-color: #c8e6c9 !important;
            color: inherit;
        }
        .sudoku td.consecutive-line-7 {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        /*.sudoku td.argyle-cell {
            background-color: #d1c4e9 !important;
            color: inherit;
        }*/
        .sudoku td.star-cell {
            background-color: #fff59d !important;
            color: inherit;
        }
        .sudoku td.killer-cage {
            border-style: dashed;
            border-width: 2px;
            border-color: #9c27b0 !important;
        }

        .sudoku td.cage-sum {
            font-size: 0.7rem;
            color: #9c27b0;
            position: absolute;
            top: 2px;
            left: 2px;
            font-weight: normal;
        }

        /* Make all special field inputs transparent so background shows through */
        .sudoku td.diagonal-cell input,
        .sudoku td.windoku-cell input,
        .sudoku td.asterisk-cell input,
        .sudoku td.even-cell input,
        .sudoku td.odd-cell input,
        .sudoku td.magic-square-cell input,
        .sudoku td.center-dot-cell input,
        .sudoku td.thermo-cell input,
        .sudoku td.arrow-circle input,
        .sudoku td.arrow-cell input,
        .sudoku td.renban-cell input,
        .sudoku td.whisper-cell input,
        .sudoku td.chain-corner-cell input,
        .sudoku td.consecutive-line-0 input,
        .sudoku td.consecutive-line-1 input,
        .sudoku td.consecutive-line-2 input,
        .sudoku td.consecutive-line-3 input,
        .sudoku td.consecutive-line-4 input,
        .sudoku td.consecutive-line-5 input,
        .sudoku td.consecutive-line-6 input,
        .sudoku td.consecutive-line-7 input,
        .sudoku td.star-cell input,
        .sudoku td.jigsaw-region-0 input,
        .sudoku td.jigsaw-region-1 input,
        .sudoku td.jigsaw-region-2 input,
        .sudoku td.jigsaw-region-3 input,
        .sudoku td.jigsaw-region-4 input,
        .sudoku td.jigsaw-region-5 input,
        .sudoku td.jigsaw-region-6 input,
        .sudoku td.jigsaw-region-7 input,
        .sudoku td.jigsaw-region-8 input,
        .sudoku td.jigsaw-region-9 input

        {
            background-color: transparent;
        }
        /* Layer 4: Interactive highlights - override special field colors */
        .sudoku td.rowcol-highlight {
            background-color: #f3e5f5 !important; /* very light blue for row/col */
            color: inherit;
        }
        .sudoku td.highlighted-user {
            background-color: #ce93d8 !important; /* purple for user-filled same number */
            color: inherit;
        }
        .sudoku td.highlighted-prefilled {
            background-color: #b995f0 !important; /* darker purple for prefilled same number */
            color: inherit;
        }
        .sudoku td.rowcol-highlight input,
        .sudoku td.highlighted-user input,
        .sudoku td.highlighted-prefilled input {
            background-color: transparent;
        }

        /* Selected cell outline - doesn't change background */
        .sudoku td.selected-cell {
            outline: 2px solid #b995f0;
            outline-offset: -2px;
            z-index: 10;
            position: relative;
        }

        /* Layer 5: Validation colors - HIGHEST PRIORITY - override everything */
        .sudoku td.correct {
            background-color: #a5d6a7 !important;
            color: inherit;
        }
        .sudoku td.correct input {
            background-color: transparent;
        }
        .sudoku td.incorrect {
            background-color: #ef9a9a !important;
            color: inherit;
        }
        .sudoku td.incorrect input {
            background-color: transparent;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            margin: 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        button.notes-toggle {
            background-color: #673AB7;
            font-weight: bold;
            position: relative;
        }
        button.notes-toggle:hover {
            background-color: #5E35B1;
        }
        button.notes-toggle.active {
            background-color: #FF9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }
        button.notes-toggle.active:hover {
            background-color: #F57C00;
        }
        button.notes-toggle .hotkey {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-left: 5px;
        }
        #message {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            font-size: 1.1rem;
            font-weight: bold;
        }
        .success {
            color: #4CAF50;
        }
        .error {
            color: #f44336;
        }
        .back-link {
            display: block;
            text-align: center;
            margin: 20px 0;
            text-decoration: none;
            color: #2196F3;
            font-size: 1rem;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        .sudoku-wrapper {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            position: relative;
        }
        .highlight-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px 18px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            min-width: 180px;
            z-index: 1000;
        }
        .highlight-controls h3 {
            margin: 0 0 8px 0;
            font-size: 0.95rem;
            color: #333;
            font-weight: 600;
        }
        .checkbox-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px;
            border-radius: 5px;
            transition: background-color 0.2s;
        }
        .checkbox-option:hover {
            background-color: #f5f5f5;
        }
        .checkbox-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #9c27b0;
        }
        .checkbox-option label {
            cursor: pointer;
            font-size: 0.9rem;
            color: #444;
            user-select: none;
        }
    </style>
</head>
<body>
    <!-- Language Switcher -->
    <div class="language-switcher">
        <div class="language-dropdown" id="languageDropdown">
            <button class="language-btn" onclick="toggleLanguageMenu()">
                <span class="language-icon">üåê</span>
                <span id="currentLanguage">{{ get_locale().upper() }}</span>
                <span class="dropdown-arrow">‚ñº</span>
            </button>
            <div class="language-menu">
                <div class="language-option {% if get_locale() == 'de' %}active{% endif %}" onclick="changeLanguage('de')">
                    <span class="flag-icon">üá©üá™</span>
                    <span>Deutsch</span>
                </div>
                <div class="language-option {% if get_locale() == 'en' %}active{% endif %}" onclick="changeLanguage('en')">
                    <span class="flag-icon">üá¨üáß</span>
                    <span>English</span>
                </div>
            </div>
        </div>
    </div>
    
    <h1>{{ _('Day') }} {{ door }} - {{ rule_name }}</h1>
    <p style="text-align: center;">{{ rule_description }}</p>

    <div class="sudoku-container">
        <div class="sudoku-wrapper">
            <div style="position: relative;">
                <svg class="diagonal-overlay" id="diagonalOverlay"></svg>
                <table class="sudoku" id="sudokuGrid">
            {% for i in range(9) %}
            <tr>
                {% for j in range(9) %}
                <td class="{{ 'prefilled' if sudoku[i][j] != 0 else '' }}" data-row="{{i}}" data-col="{{j}}" {% if sudoku[i][j] != 0 %}tabindex="0"{% endif %}>
                    {% if sudoku[i][j] != 0 %}
                        {{ sudoku[i][j] }}
                    {% else %}
                        <div class="notes" data-row="{{i}}" data-col="{{j}}"></div>
                        <input type="text" maxlength="1" data-row="{{i}}" data-col="{{j}}" />
                    {% endif %}
                </td>
                {% endfor %}
            </tr>
            {% endfor %}
        </table>
            </div>
        </div>
    </div>

    <!-- Fixed position highlight controls at bottom right -->
    <div class="highlight-controls">
        <h3>{{ _('Highlights') }}</h3>
        <div class="checkbox-option">
            <input type="checkbox" id="toggleRowCol" checked>
            <label for="toggleRowCol">{{ _('Row/Column') }}</label>
        </div>
        <div class="checkbox-option">
            <input type="checkbox" id="toggleSameNumber" checked>
            <label for="toggleSameNumber">{{ _('Same Number') }}</label>
        </div>
    </div>

    <div class="controls">
        <button id="notesToggle" onclick="toggleNotesMode()" class="notes-toggle">
            üìù {{ _('Notes Mode') }} <span class="hotkey">(Space)</span>
        </button>
        <br>
        <button onclick="checkSolution()">{{ _('Check Solution') }}</button>
        <button onclick="undo()" class="secondary">‚Ü∂ {{ _('Undo') }}</button>
        <button onclick="resetBoard()" class="secondary">{{ _('Reset') }}</button>
        <button onclick="generateNewPuzzle()" class="secondary">{{ _('Generate New Puzzle') }}</button>
    </div>

    <div id="message"></div>
    <div id="generation-message" style="text-align: center; margin: 10px 0; padding: 10px; font-size: 1rem;"></div>

    <a href="/" class="back-link">‚Üê {{ _('Back to Calendar') }}</a>

    <script>
        // Store the solution and metadata
        const solution = {{ solution | tojson }};
        const initialPuzzle = {{ sudoku | tojson }};
        const metadata = {{ metadata | tojson }};

        // Highlight settings (default enabled)
        let highlightRowColEnabled = true;
        let highlightSameNumberEnabled = true;

        // Notes mode (default disabled)
        let notesMode = false;
        const cellNotes = {}; // Store notes for each cell: {row,col: Set of numbers}

        // Undo system - track all user actions
        const undoHistory = [];
        const MAX_UNDO_STEPS = 100; // Limit history to prevent memory issues

        function recordAction(action) {
            undoHistory.push(action);
            // Limit history size
            if (undoHistory.length > MAX_UNDO_STEPS) {
                undoHistory.shift();
            }
        }

        function undo() {
            if (undoHistory.length === 0) {
                const messageDiv = document.getElementById('message');
                messageDiv.innerHTML = '<span style="color: #ff9800;">Nothing to undo</span>';
                setTimeout(() => { messageDiv.innerHTML = ''; }, 2000);
                return;
            }

            const action = undoHistory.pop();

            if (action.type === 'number') {
                // Undo number entry
                const input = document.querySelector(`input[data-row="${action.row}"][data-col="${action.col}"]`);
                if (input) {
                    input.value = action.oldValue;
                    const cell = input.parentElement;
                    cell.classList.remove('correct', 'incorrect');
                }
            } else if (action.type === 'note') {
                // Undo note action
                const key = `${action.row},${action.col}`;
                if (action.operation === 'add') {
                    // Remove the note that was added
                    if (cellNotes[key]) {
                        cellNotes[key].delete(action.value);
                        if (cellNotes[key].size === 0) {
                            delete cellNotes[key];
                        }
                    }
                } else if (action.operation === 'clear') {
                    // Restore the notes that were cleared
                    cellNotes[key] = new Set(action.oldNotes);
                }
                updateNotesDisplay(action.row, action.col);
            }
        }

        // Toggle notes mode function
        function toggleNotesMode() {
            notesMode = !notesMode;
            const btn = document.getElementById('notesToggle');
            if (notesMode) {
                btn.classList.add('active');
                btn.innerHTML = 'üìù Notes Mode <span class="hotkey">(Space)</span> - ON';
            } else {
                btn.classList.remove('active');
                btn.innerHTML = 'üìù Notes Mode <span class="hotkey">(Space)</span>';
            }
        }

        // Add global spacebar listener
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' && e.target.tagName !== 'INPUT') {
                e.preventDefault();
                toggleNotesMode();
            }
        });

        // Add event listeners for checkboxes
        document.addEventListener('DOMContentLoaded', function() {
            const rowColCheckbox = document.getElementById('toggleRowCol');
            const sameNumberCheckbox = document.getElementById('toggleSameNumber');

            rowColCheckbox.addEventListener('change', function() {
                highlightRowColEnabled = this.checked;
                // Refresh highlights if a cell is currently selected
                const selectedInput = document.querySelector('.sudoku input:focus');
                const selectedPrefilled = document.querySelector('.sudoku td.prefilled:focus');
                if (selectedInput) {
                    highlightSameNumbersAndRowCol(selectedInput, selectedInput.value);
                } else if (selectedPrefilled) {
                    highlightSameNumbersAndRowCol(selectedPrefilled, selectedPrefilled.textContent.trim());
                }
            });

            sameNumberCheckbox.addEventListener('change', function() {
                highlightSameNumberEnabled = this.checked;
                // Refresh highlights if a cell is currently selected
                const selectedInput = document.querySelector('.sudoku input:focus');
                const selectedPrefilled = document.querySelector('.sudoku td.prefilled:focus');
                if (selectedInput) {
                    highlightSameNumbersAndRowCol(selectedInput, selectedInput.value);
                } else if (selectedPrefilled) {
                    highlightSameNumbersAndRowCol(selectedPrefilled, selectedPrefilled.textContent.trim());
                }
            });

            applySpecialCellHighlighting();
            drawArgyleDiagonals();
        });

        function applySpecialCellHighlighting() {
            const rule = metadata.rule;

            // Diagonal cells (Diagonal Rule)
            if (rule.diagonal_cells) {
                rule.diagonal_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('diagonal-cell');
                });
            } else if (rule.name && rule.name.includes('Diagonal')) {
                // Fallback for old metadata without diagonal_cells
                for (let i = 0; i < 9; i++) {
                    // Main diagonal
                    const cell1 = document.querySelector(`td[data-row="${i}"][data-col="${i}"]`);
                    if (cell1) cell1.classList.add('diagonal-cell');

                    // Anti-diagonal
                    const cell2 = document.querySelector(`td[data-row="${i}"][data-col="${8-i}"]`);
                    if (cell2) cell2.classList.add('diagonal-cell');
                }
            }

            // Windoku regions
            if (rule.windoku_regions) {
                rule.windoku_regions.forEach(region => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('windoku-cell');
                    });
                });
            }

            // Asterisk cells
            if (rule.asterisk_cells) {
                rule.asterisk_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('asterisk-cell');
                });
            }

            // Even cells
            if (rule.even_cells) {
                rule.even_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('even-cell');
                });
            }

            // Odd cells
            if (rule.odd_cells) {
                rule.odd_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('odd-cell');
                });
            }

            // Magic Square cells
            if (rule.magic_box_location) {
                const loc = rule.magic_box_location;
                loc.rows.forEach(row => {
                    loc.cols.forEach(col => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('magic-square-cell');
                    });
                });
            }

            // Center Dot cells (center of each 3x3 box)
            if (rule.center_dot_cells) {
                rule.center_dot_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('center-dot-cell');
                });
            } else if (rule.name && rule.name.includes('Center Dot')) {
                // Fallback for old metadata without center_dot_cells
                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        const centerRow = boxRow * 3 + 1;
                        const centerCol = boxCol * 3 + 1;
                        const cell = document.querySelector(`td[data-row="${centerRow}"][data-col="${centerCol}"]`);
                        if (cell) cell.classList.add('center-dot-cell');
                    }
                }
            }

            // Killer Sudoku cages
            if (rule.cages) {
                rule.cages.forEach((cage, index) => {
                    cage.cells.forEach(([row, col], cellIndex) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.classList.add('killer-cage');
                            // Add sum label to first cell in cage
                            if (cellIndex === 0) {
                                const sumLabel = document.createElement('div');
                                sumLabel.className = 'cage-sum';
                                sumLabel.textContent = cage.sum;
                                cell.insertBefore(sumLabel, cell.firstChild);
                            }
                        }
                    });
                });
            }

            // Thermometer cells
            if (rule.thermometers) {
                rule.thermometers.forEach(thermo => {
                    thermo.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('thermo-cell');
                    });
                });
            }

            // Arrow Sudoku
            if (rule.arrows) {
                rule.arrows.forEach(arrow => {
                    // Circle cell
                    const [circleRow, circleCol] = arrow.circle;
                    const circleCell = document.querySelector(`td[data-row="${circleRow}"][data-col="${circleCol}"]`);
                    if (circleCell) circleCell.classList.add('arrow-circle');

                    // Arrow cells
                    arrow.arrow_cells.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('arrow-cell');
                    });
                });
            }

            // Renban lines
            if (rule.renban_lines) {
                rule.renban_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('renban-cell');
                    });
                });
            }

            // Jigsaw regions
            if (rule.jigsaw_regions) {
                rule.jigsaw_regions.forEach((region, regionIndex) => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`jigsaw-region-${regionIndex}`);
                    });
                });
            }

            // Whisper lines
            if (rule.whisper_lines) {
                rule.whisper_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('whisper-cell');
                    });
                });
            }

            // Chain Sudoku corner cells
            if (rule.corner_cells) {
                rule.corner_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('chain-corner-cell');
                });
            }

            // Consecutive lines
            if (rule.consecutive_lines) {
                rule.consecutive_lines.forEach((line, lineIndex) => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`consecutive-line-${lineIndex % 8}`);
                    });
                });
            }

            // Argyle cells (diagonals within boxes)
            if (rule.argyle_cells) {
                rule.argyle_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('argyle-cell');
                });
            }

            // Star pattern cells
            if (rule.star_cells) {
                rule.star_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('star-cell');
                });
            }

            // XV pairs - mark cells involved in X or V constraints
            if (rule.x_pairs) {
                rule.x_pairs.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            // Add a visual indicator for XV constraints
                            cell.style.borderColor = '#ff6b6b';
                            cell.style.borderWidth = '2px';
                        }
                    });
                });
            }

            if (rule.v_pairs) {
                rule.v_pairs.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            // Add a visual indicator for XV constraints
                            cell.style.borderColor = '#4ecdc4';
                            cell.style.borderWidth = '2px';
                        }
                    });
                });
            }

            // Futoshiki inequalities - draw inequality symbols
            if (rule.inequalities) {
                rule.inequalities.forEach(inequality => {
                    const [r1, c1] = inequality.cell1;
                    const [r2, c2] = inequality.cell2;
                    const operator = inequality.operator;
                    
                    // Add visual styling to cells involved in inequalities
                    const cell1 = document.querySelector(`td[data-row="${r1}"][data-col="${c1}"]`);
                    const cell2 = document.querySelector(`td[data-row="${r2}"][data-col="${c2}"]`);
                    if (cell1) cell1.style.borderColor = '#9c27b0';
                    if (cell2) cell2.style.borderColor = '#9c27b0';
                    
                    // TODO: Draw inequality symbols between cells
                });
            }

            // Kropki dots - mark cells with white or black dots
            if (rule.white_dots) {
                rule.white_dots.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.style.borderColor = '#ffffff';
                            cell.style.borderWidth = '2px';
                        }
                    });
                });
            }

            if (rule.black_dots) {
                rule.black_dots.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.style.borderColor = '#000000';
                            cell.style.borderWidth = '3px';
                        }
                    });
                });
            }
        }

        // Draw argyle diagonal lines
        function drawArgyleDiagonals() {
            const rule = metadata.rule;
            if (!rule.argyle_diagonals) return;

            const svg = document.getElementById('diagonalOverlay');
            const table = document.getElementById('sudokuGrid');

            // Get table dimensions
            const tableRect = table.getBoundingClientRect();
            const containerRect = table.parentElement.getBoundingClientRect();

            // Set SVG dimensions to match table
            svg.setAttribute('width', tableRect.width);
            svg.setAttribute('height', tableRect.height);
            svg.style.width = tableRect.width + 'px';
            svg.style.height = tableRect.height + 'px';
            svg.style.left = (tableRect.left - containerRect.left) + 'px';
            svg.style.top = (tableRect.top - containerRect.top) + 'px';

            const cellSize = 50; // Cell size from CSS
            const borderWidth = 3; // Table border width

            // Helper function to get cell center coordinates
            function getCellCenter(row, col) {
                // Account for different border widths
                let x = borderWidth + col * cellSize;
                let y = borderWidth + row * cellSize;

                // Add thicker borders after columns 3 and 6
                if (col >= 3) x += 1;
                if (col >= 6) x += 1;

                // Add thicker borders after rows 3 and 6
                if (row >= 3) y += 1;
                if (row >= 6) y += 1;

                // Add half cell size to get center
                x += cellSize / 2;
                y += cellSize / 2;

                return { x, y };
            }

            // Color palette for different diagonals
            const colors = ['#FF4F4F7C', '#FF4F4F7C', '#FF4F4F7C', '#FF4F4F7C'];

            // Draw each diagonal
            rule.argyle_diagonals.forEach((diagonal, index) => {
                const color = colors[index % colors.length];

                // Create a path for this diagonal
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Build path data
                let pathData = '';
                diagonal.forEach((cell, cellIndex) => {
                    const [row, col] = cell;
                    const center = getCellCenter(row, col);

                    if (cellIndex === 0) {
                        pathData += `M ${center.x} ${center.y}`;
                    } else {
                        pathData += ` L ${center.x} ${center.y}`;
                    }
                });

                path.setAttribute('d', pathData);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', '3');
                path.setAttribute('stroke-opacity', '0.6');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');

                svg.appendChild(path);
            });
        }

        // Apply highlighting when page loads
        document.addEventListener('DOMContentLoaded', function() {
            applySpecialCellHighlighting();
            drawArgyleDiagonals();
        });

        // Only allow numbers 1-9
        document.querySelectorAll('.sudoku input').forEach(input => {
            input.addEventListener('input', function(e) {
                const value = e.target.value;
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                const key = `${row},${col}`;

                if (notesMode) {
                    // Notes mode: add number to notes
                    if (value && /^[1-9]$/.test(value)) {
                        if (!cellNotes[key]) {
                            cellNotes[key] = new Set();
                        }
                        // Record action before adding note
                        recordAction({
                            type: 'note',
                            operation: 'add',
                            row: row,
                            col: col,
                            value: value
                        });
                        cellNotes[key].add(value);
                        updateNotesDisplay(row, col);
                        e.target.value = ''; // Clear input after adding note
                    } else {
                        e.target.value = '';
                    }
                } else {
                    // Normal mode: single number entry
                    if (value && (!/^[1-9]$/.test(value))) {
                        e.target.value = '';
                    } else if (value) {
                        // Record the old value before changing
                        const oldValue = e.target.getAttribute('data-old-value') || '';
                        recordAction({
                            type: 'number',
                            row: row,
                            col: col,
                            oldValue: oldValue,
                            newValue: value
                        });
                        // Store current value for next change
                        e.target.setAttribute('data-old-value', value);

                        // Clear notes when entering a number in normal mode
                        if (cellNotes[key]) {
                            delete cellNotes[key];
                            updateNotesDisplay(row, col);
                        }
                        highlightSameNumbersAndRowCol(e.target, value);
                    } else {
                        // Clearing the cell (backspace/delete)
                        const oldValue = e.target.getAttribute('data-old-value') || '';
                        if (oldValue) {
                            recordAction({
                                type: 'number',
                                row: row,
                                col: col,
                                oldValue: oldValue,
                                newValue: ''
                            });
                            e.target.setAttribute('data-old-value', '');
                        }
                        highlightSameNumbersAndRowCol(e.target, value);
                    }
                }
            });

            input.addEventListener('focus', function(e) {
                const value = e.target.value;
                highlightSameNumbersAndRowCol(e.target, value);
            });

            input.addEventListener('blur', function(e) {
                clearHighlights();
            });

            // Add keyboard navigation
            input.addEventListener('keydown', function(e) {
                // Allow spacebar to toggle notes mode even in input fields
                if (e.code === 'Space') {
                    e.preventDefault();
                    toggleNotesMode();
                    return;
                }

                // Handle Delete/Backspace in notes mode
                if (notesMode && (e.key === 'Delete' || e.key === 'Backspace')) {
                    e.preventDefault();
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    const key = `${row},${col}`;
                    // Clear all notes for this cell
                    if (cellNotes[key]) {
                        // Record action before clearing
                        recordAction({
                            type: 'note',
                            operation: 'clear',
                            row: row,
                            col: col,
                            oldNotes: Array.from(cellNotes[key])
                        });
                        delete cellNotes[key];
                        updateNotesDisplay(row, col);
                    }
                    return;
                }

                handleKeyboardNavigation(e, e.target);
            });
        });

        // Add click, focus, blur and keyboard navigation listeners to prefilled cells
        document.querySelectorAll('.sudoku td.prefilled').forEach(cell => {
            cell.addEventListener('click', function(e) {
                cell.focus();
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });

            cell.addEventListener('focus', function(e) {
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });

            cell.addEventListener('blur', function(e) {
                clearHighlights();
            });

            cell.addEventListener('keydown', function(e) {
                handleKeyboardNavigation(e, cell);
            });
        });

        // Unified keyboard navigation handler
        function handleKeyboardNavigation(e, element) {
            let row, col;
            if (element.tagName === 'INPUT') {
                row = parseInt(element.dataset.row);
                col = parseInt(element.dataset.col);
            } else {
                row = parseInt(element.getAttribute('data-row'));
                col = parseInt(element.getAttribute('data-col'));
            }

            let newRow = row;
            let newCol = col;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    newRow = row > 0 ? row - 1 : row;
                    break;
                case 'ArrowDown':
                case 'Enter':
                    e.preventDefault();
                    newRow = row < 8 ? row + 1 : row;
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    newCol = col > 0 ? col - 1 : col;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    newCol = col < 8 ? col + 1 : col;
                    break;
                default:
                    return; // Don't navigate for other keys
            }

            if (newRow !== row || newCol !== col) {
                // Try to find input first, then prefilled cell
                let nextCell = document.querySelector(`input[data-row="${newRow}"][data-col="${newCol}"]`);
                if (nextCell) {
                    nextCell.focus();
                    nextCell.select();
                } else {
                    nextCell = document.querySelector(`td[data-row="${newRow}"][data-col="${newCol}"].prefilled`);
                    if (nextCell) {
                        nextCell.focus();
                    }
                }
            }
        }

        // Clear highlights when clicking outside the sudoku grid
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.sudoku')) {
                clearHighlights();
            }
        });

        function checkSolution() {
            let allCorrect = true;
            let allFilled = true;
            const inputs = document.querySelectorAll('.sudoku input');

            inputs.forEach(input => {
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                const value = input.value;
                const cell = input.parentElement;

                // Remove previous styling
                cell.classList.remove('correct', 'incorrect');

                if (!value) {
                    allFilled = false;
                    return;
                }

                if (parseInt(value) === solution[row][col]) {
                    cell.classList.add('correct');
                } else {
                    cell.classList.add('incorrect');
                    allCorrect = false;
                }
            });

            const messageDiv = document.getElementById('message');
            if (!allFilled) {
                messageDiv.innerHTML = '<span class="error">Please fill in all cells first!</span>';
            } else if (allCorrect) {
                messageDiv.innerHTML = '<span class="success">üéâ Congratulations! You solved the Sudoku correctly! üéâ</span>';
            } else {
                messageDiv.innerHTML = '<span class="error">Some cells are incorrect. Keep trying!</span>';
            }
        }

        function clearAll() {
            document.querySelectorAll('.sudoku input').forEach(input => {
                input.value = '';
                input.removeAttribute('data-old-value');
                input.parentElement.classList.remove('correct', 'incorrect');
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                const key = `${row},${col}`;
                if (cellNotes[key]) {
                    delete cellNotes[key];
                    updateNotesDisplay(row, col);
                }
            });
            document.getElementById('message').innerHTML = '';
        }

        function resetBoard() {
            clearAll();
            // Clear undo history on reset
            undoHistory.length = 0;
        }

        // Function to update the notes display for a cell
        function updateNotesDisplay(row, col) {
            const key = `${row},${col}`;
            const notesDiv = document.querySelector(`.notes[data-row="${row}"][data-col="${col}"]`);
            if (notesDiv) {
                if (cellNotes[key] && cellNotes[key].size > 0) {
                    // Sort and display notes
                    const sortedNotes = Array.from(cellNotes[key]).sort().join(' ');
                    notesDiv.textContent = sortedNotes;
                } else {
                    notesDiv.textContent = '';
                }
            }
        }

        function generateNewPuzzle() {
            const messageDiv = document.getElementById('generation-message');
            const doorNumber = {{ door }};

            // Disable button and show loading message
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';
            messageDiv.innerHTML = '<span style="color: #2196F3;">Generating new puzzle... This may take a moment.</span>';

            // Call the Flask route to generate a new puzzle
            fetch(`/generate/${doorNumber}`)
                .then(response => {
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response. This may be a permissions issue on the server.');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        messageDiv.innerHTML = '<span style="color: #4CAF50;">‚úì ' + data.message + ' Reloading...</span>';
                        // Reload the page after a short delay to show the new puzzle
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        messageDiv.innerHTML = '<span style="color: #f44336;">‚úó ' + data.message + '</span>';
                        button.disabled = false;
                        button.textContent = 'Generate New Puzzle';
                    }
                })
                .catch(error => {
                    console.error('Generation error:', error);
                    messageDiv.innerHTML = '<span style="color: #f44336;">‚úó Error: ' + error.message + '</span>';
                    button.disabled = false;
                    button.textContent = 'Generate New Puzzle';
                });
        }

        function highlightSameNumbersAndRowCol(selectedCell, number) {
            clearHighlights();
            if (!selectedCell) return;

            // Get row and col
            let row = null, col = null;
            if (selectedCell.tagName === 'INPUT') {
                row = parseInt(selectedCell.dataset.row);
                col = parseInt(selectedCell.dataset.col);
            } else {
                row = parseInt(selectedCell.getAttribute('data-row'));
                col = parseInt(selectedCell.getAttribute('data-col'));
            }

            // Highlight row and column (only if enabled)
            if (highlightRowColEnabled) {
                document.querySelectorAll('.sudoku td').forEach(cell => {
                    const cellRow = parseInt(cell.getAttribute('data-row'));
                    const cellCol = parseInt(cell.getAttribute('data-col'));
                    if (cellRow === row || cellCol === col) {
                        cell.classList.add('rowcol-highlight');
                    }
                });
            }

            // Highlight selected cell
            if (selectedCell.tagName === 'INPUT') {
                selectedCell.parentElement.classList.add('selected-cell');
            } else {
                selectedCell.classList.add('selected-cell');
            }

            // Highlight all cells with the same number (only if enabled)
            if (highlightSameNumberEnabled && number) {
                document.querySelectorAll('.sudoku td').forEach(cell => {
                    const text = cell.textContent.trim();
                    const input = cell.querySelector('input');
                    if (text === number && cell.classList.contains('prefilled')) {
                        cell.classList.add('highlighted-prefilled');
                    } else if (input && input.value === number && input.value !== '' && !cell.classList.contains('prefilled')) {
                        cell.classList.add('highlighted-user');
                    }
                });
            }
        }

        function clearHighlights() {
            document.querySelectorAll('.sudoku td').forEach(cell => {
                cell.classList.remove('highlighted', 'highlighted-prefilled', 'highlighted-user', 'rowcol-highlight', 'selected-cell');
            });
        }
        
        function toggleLanguageMenu() {
            const dropdown = document.getElementById('languageDropdown');
            dropdown.classList.toggle('active');
        }
        
        function changeLanguage(lang) {
            fetch('/set_language/' + lang)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        location.reload();
                    }
                });
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('languageDropdown');
            if (!dropdown.contains(event.target)) {
                dropdown.classList.remove('active');
            }
        });
    </script>
</body>
</html>
