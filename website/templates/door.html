<!DOCTYPE html>
<html>
<head>
    <title>Door {{door}} - Interactive Sudoku</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .sudoku-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .sudoku {
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #000;
        }
        .sudoku td {
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            position: relative;
            border: none;
            box-sizing: border-box;
        }
        /* Top borders - thin by default */
        .sudoku td {
            border-top: 1px solid #bbb;
        }
        /* Left borders - thin by default */
        .sudoku td {
            border-left: 1px solid #bbb;
        }
        /* First row gets no top border (outer border handles it) */
        .sudoku tr:first-child td {
            border-top: none;
        }
        /* First column gets no left border (outer border handles it) */
        .sudoku td:first-child {
            border-left: none;
        }
        /* Thick top borders after rows 3 and 6 (i.e., on rows 4 and 7) */
        .sudoku tr:nth-child(4) td,
        .sudoku tr:nth-child(7) td {
            border-top: 2px solid #000;
        }
        /* Thick left borders on columns 4 and 7 */
        .sudoku td:nth-child(4),
        .sudoku td:nth-child(7) {
            border-left: 2px solid #000;
        }
        .sudoku td input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            outline: none;
            background-color: #fffef0;
        }

        /* Layer 1: Base background - LOWEST PRIORITY */
        /* Default input background is set above */

        /* Layer 2: Prefilled cells - overrides background, borders show through */
        .sudoku td.prefilled {
            background-color: #e8e8e8;
            color: #000;
        }

        /* Layer 3: Special field colors - override prefilled cells, borders show through */
        .sudoku td.diagonal-cell {
            background-color: #e8f4f8 !important;
        }
        .sudoku td.windoku-cell {
            background-color: #e3f2fd !important;
        }
        .sudoku td.asterisk-cell {
            background-color: #fff9c4 !important;
        }
        .sudoku td.even-cell {
            background-color: #c8e6c9 !important;
        }
        .sudoku td.odd-cell {
            background-color: #ffccbc !important;
        }
        .sudoku td.magic-square-cell {
            background-color: #f3e5f5 !important;
        }
        .sudoku td.center-dot-cell {
            background-color: #ffe0b2 !important;
        }
        .sudoku td.thermo-cell {
            background-color: #e1f5fe !important;
        }
        .sudoku td.arrow-circle {
            background-color: #fff9c4 !important;
            border-radius: 50%;
        }
        .sudoku td.arrow-cell {
            background-color: #fffde7 !important;
        }
        .sudoku td.renban-cell {
            background-color: #f3e5f5 !important;
        }
        .sudoku td.jigsaw-region-0 {
            background-color: #ffebee !important;
        }
        .sudoku td.jigsaw-region-1 {
            background-color: #e8f5e9 !important;
        }
        .sudoku td.jigsaw-region-2 {
            background-color: #e3f2fd !important;
        }
        .sudoku td.jigsaw-region-3 {
            background-color: #fff3e0 !important;
        }
        .sudoku td.jigsaw-region-4 {
            background-color: #f3e5f5 !important;
        }
        .sudoku td.jigsaw-region-5 {
            background-color: #fce4ec !important;
        }
        .sudoku td.jigsaw-region-6 {
            background-color: #e0f2f1 !important;
        }
        .sudoku td.jigsaw-region-7 {
            background-color: #fff9c4 !important;
        }
        .sudoku td.jigsaw-region-8 {
            background-color: #e1f5fe !important;
        }
        .sudoku td.whisper-cell {
            background-color: #e1bee7 !important;
        }
        .sudoku td.chain-corner-cell {
            background-color: #ffecb3 !important;
        }
        .sudoku td.consecutive-cell {
            background-color: #c5e1a5 !important;
        }
        .sudoku td.killer-cage {
            position: relative;
            border: 2px dashed #9c27b0 !important;
        }
        .sudoku td.cage-sum {
            font-size: 0.7rem;
            color: #9c27b0;
            position: absolute;
            top: 2px;
            left: 2px;
            font-weight: normal;
        }

        /* Make all special field inputs transparent so background shows through */
        .sudoku td.diagonal-cell input,
        .sudoku td.windoku-cell input,
        .sudoku td.asterisk-cell input,
        .sudoku td.even-cell input,
        .sudoku td.odd-cell input,
        .sudoku td.magic-square-cell input,
        .sudoku td.center-dot-cell input,
        .sudoku td.thermo-cell input,
        .sudoku td.arrow-circle input,
        .sudoku td.arrow-cell input,
        .sudoku td.renban-cell input,
        .sudoku td.whisper-cell input,
        .sudoku td.chain-corner-cell input,
        .sudoku td.consecutive-cell input {
            background-color: transparent;
        }
        /* Layer 4: Interactive highlights - override special field colors */
        .sudoku td.rowcol-highlight {
            background-color: #e3f2fd !important; /* very light blue for row/col */
        }
        .sudoku td.highlighted-user {
            background-color: #ce93d8 !important; /* purple for user-filled same number */
        }
        .sudoku td.highlighted-prefilled {
            background-color: #b995f0 !important; /* darker purple for prefilled same number */
        }
        .sudoku td.rowcol-highlight input,
        .sudoku td.highlighted-user input,
        .sudoku td.highlighted-prefilled input {
            background-color: transparent;
        }

        /* Selected cell outline - doesn't change background */
        .sudoku td.selected-cell {
            outline: 3px solid #1565c0;
            outline-offset: -3px;
            z-index: 10;
            position: relative;
        }

        /* Layer 5: Validation colors - HIGHEST PRIORITY - override everything */
        .sudoku td.correct {
            background-color: #a5d6a7 !important;
        }
        .sudoku td.correct input {
            background-color: transparent;
        }
        .sudoku td.incorrect {
            background-color: #ef9a9a !important;
        }
        .sudoku td.incorrect input {
            background-color: transparent;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            margin: 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        #message {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            font-size: 1.1rem;
            font-weight: bold;
        }
        .success {
            color: #4CAF50;
        }
        .error {
            color: #f44336;
        }
        .back-link {
            display: block;
            text-align: center;
            margin: 20px 0;
            text-decoration: none;
            color: #2196F3;
            font-size: 1rem;
        }
        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Day {{ door }} - {{ metadata.rule.name }}</h1>
    <p style="text-align: center;">{{ metadata.rule.description }}</p>

    <div class="sudoku-container">
        <table class="sudoku" id="sudokuGrid">
            {% for i in range(9) %}
            <tr>
                {% for j in range(9) %}
                <td class="{{ 'prefilled' if sudoku[i][j] != 0 else '' }}" data-row="{{i}}" data-col="{{j}}">
                    {% if sudoku[i][j] != 0 %}
                        {{ sudoku[i][j] }}
                    {% else %}
                        <input type="text" maxlength="1" data-row="{{i}}" data-col="{{j}}" />
                    {% endif %}
                </td>
                {% endfor %}
            </tr>
            {% endfor %}
        </table>
    </div>

    <div class="controls">
        <button onclick="checkSolution()">Check Solution</button>
        <button onclick="clearAll()" class="secondary">Clear All</button>
        <button onclick="resetBoard()" class="secondary">Reset</button>
        <button onclick="generateNewPuzzle()" class="secondary">Generate New Puzzle</button>
    </div>

    <div id="message"></div>
    <div id="generation-message" style="text-align: center; margin: 10px 0; padding: 10px; font-size: 1rem;"></div>

    <a href="/" class="back-link">‚Üê Back to Calendar</a>

    <script>
        // Store the solution and metadata
        const solution = {{ solution | tojson }};
        const initialPuzzle = {{ sudoku | tojson }};
        const metadata = {{ metadata | tojson }};

        // Apply special cell highlighting based on metadata
        function applySpecialCellHighlighting() {
            const rule = metadata.rule;
            
            // Diagonal cells (Diagonal Rule)
            if (rule.name && rule.name.includes('Diagonal')) {
                for (let i = 0; i < 9; i++) {
                    // Main diagonal
                    const cell1 = document.querySelector(`td[data-row="${i}"][data-col="${i}"]`);
                    if (cell1) cell1.classList.add('diagonal-cell');
                    
                    // Anti-diagonal
                    const cell2 = document.querySelector(`td[data-row="${i}"][data-col="${8-i}"]`);
                    if (cell2) cell2.classList.add('diagonal-cell');
                }
            }
            
            // Windoku regions
            if (rule.windoku_regions) {
                rule.windoku_regions.forEach(region => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('windoku-cell');
                    });
                });
            }
            
            // Asterisk cells
            if (rule.asterisk_cells) {
                rule.asterisk_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('asterisk-cell');
                });
            }
            
            // Even cells
            if (rule.even_cells) {
                rule.even_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('even-cell');
                });
            }
            
            // Odd cells
            if (rule.odd_cells) {
                rule.odd_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('odd-cell');
                });
            }

            // Magic Square cells
            if (rule.magic_box_location) {
                const loc = rule.magic_box_location;
                loc.rows.forEach(row => {
                    loc.cols.forEach(col => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('magic-square-cell');
                    });
                });
            }

            // Center Dot cells (center of each 3x3 box)
            if (rule.name && rule.name.includes('Center Dot')) {
                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        const centerRow = boxRow * 3 + 1;
                        const centerCol = boxCol * 3 + 1;
                        const cell = document.querySelector(`td[data-row="${centerRow}"][data-col="${centerCol}"]`);
                        if (cell) cell.classList.add('center-dot-cell');
                    }
                }
            }

            // Killer Sudoku cages
            if (rule.cages) {
                rule.cages.forEach((cage, index) => {
                    cage.cells.forEach(([row, col], cellIndex) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.classList.add('killer-cage');
                            // Add sum label to first cell in cage
                            if (cellIndex === 0) {
                                const sumLabel = document.createElement('div');
                                sumLabel.className = 'cage-sum';
                                sumLabel.textContent = cage.sum;
                                cell.insertBefore(sumLabel, cell.firstChild);
                            }
                        }
                    });
                });
            }

            // Thermometer cells
            if (rule.thermometers) {
                rule.thermometers.forEach(thermo => {
                    thermo.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('thermo-cell');
                    });
                });
            }

            // Arrow Sudoku
            if (rule.arrows) {
                rule.arrows.forEach(arrow => {
                    // Circle cell
                    const [circleRow, circleCol] = arrow.circle;
                    const circleCell = document.querySelector(`td[data-row="${circleRow}"][data-col="${circleCol}"]`);
                    if (circleCell) circleCell.classList.add('arrow-circle');

                    // Arrow cells
                    arrow.arrow_cells.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('arrow-cell');
                    });
                });
            }

            // Renban lines
            if (rule.renban_lines) {
                rule.renban_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('renban-cell');
                    });
                });
            }

            // Jigsaw regions
            if (rule.jigsaw_regions) {
                rule.jigsaw_regions.forEach((region, regionIndex) => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`jigsaw-region-${regionIndex}`);
                    });
                });
            }

            // Whisper lines
            if (rule.whisper_lines) {
                rule.whisper_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('whisper-cell');
                    });
                });
            }

            // Chain Sudoku corner cells
            if (rule.corner_cells) {
                rule.corner_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('chain-corner-cell');
                });
            }

            // Consecutive pairs
            if (rule.consecutive_pairs) {
                rule.consecutive_pairs.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('consecutive-cell');
                    });
                });
            }
        }

        // Apply highlighting when page loads
        document.addEventListener('DOMContentLoaded', function() {
            applySpecialCellHighlighting();
        });

        // Only allow numbers 1-9
        document.querySelectorAll('.sudoku input').forEach(input => {
            input.addEventListener('input', function(e) {
                const value = e.target.value;
                if (value && (!/^[1-9]$/.test(value))) {
                    e.target.value = '';
                } else {
                    highlightSameNumbersAndRowCol(e.target, value);
                }
            });

            input.addEventListener('focus', function(e) {
                const value = e.target.value;
                highlightSameNumbersAndRowCol(e.target, value);
            });

            input.addEventListener('blur', function(e) {
                clearHighlights();
            });

            // Add keyboard navigation
            input.addEventListener('keydown', function(e) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                let newRow = row;
                let newCol = col;

                switch(e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        newRow = row > 0 ? row - 1 : row;
                        break;
                    case 'ArrowDown':
                    case 'Enter':
                        e.preventDefault();
                        newRow = row < 8 ? row + 1 : row;
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        newCol = col > 0 ? col - 1 : col;
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        newCol = col < 8 ? col + 1 : col;
                        break;
                }

                if (newRow !== row || newCol !== col) {
                    const nextInput = document.querySelector(`input[data-row="${newRow}"][data-col="${newCol}"]`);
                    if (nextInput) {
                        nextInput.focus();
                        nextInput.select();
                    }
                }
            });
        });

        // Add click listeners to prefilled cells
        document.querySelectorAll('.sudoku td.prefilled').forEach(cell => {
            cell.addEventListener('click', function(e) {
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });
        });

        // Clear highlights when clicking outside the sudoku grid
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.sudoku')) {
                clearHighlights();
            }
        });

        function checkSolution() {
            let allCorrect = true;
            let allFilled = true;
            const inputs = document.querySelectorAll('.sudoku input');

            inputs.forEach(input => {
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                const value = input.value;
                const cell = input.parentElement;

                // Remove previous styling
                cell.classList.remove('correct', 'incorrect');

                if (!value) {
                    allFilled = false;
                    return;
                }

                if (parseInt(value) === solution[row][col]) {
                    cell.classList.add('correct');
                } else {
                    cell.classList.add('incorrect');
                    allCorrect = false;
                }
            });

            const messageDiv = document.getElementById('message');
            if (!allFilled) {
                messageDiv.innerHTML = '<span class="error">Please fill in all cells first!</span>';
            } else if (allCorrect) {
                messageDiv.innerHTML = '<span class="success">üéâ Congratulations! You solved the Sudoku correctly! üéâ</span>';
            } else {
                messageDiv.innerHTML = '<span class="error">Some cells are incorrect. Keep trying!</span>';
            }
        }

        function clearAll() {
            document.querySelectorAll('.sudoku input').forEach(input => {
                input.value = '';
                input.parentElement.classList.remove('correct', 'incorrect');
            });
            document.getElementById('message').innerHTML = '';
        }

        function resetBoard() {
            clearAll();
        }

        function generateNewPuzzle() {
            const messageDiv = document.getElementById('generation-message');
            const doorNumber = {{ door }};

            // Disable button and show loading message
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';
            messageDiv.innerHTML = '<span style="color: #2196F3;">Generating new puzzle... This may take a moment.</span>';

            // Call the Flask route to generate a new puzzle
            fetch(`/generate/${doorNumber}`)
                .then(response => {
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response. This may be a permissions issue on the server.');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        messageDiv.innerHTML = '<span style="color: #4CAF50;">‚úì ' + data.message + ' Reloading...</span>';
                        // Reload the page after a short delay to show the new puzzle
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        messageDiv.innerHTML = '<span style="color: #f44336;">‚úó ' + data.message + '</span>';
                        button.disabled = false;
                        button.textContent = 'Generate New Puzzle';
                    }
                })
                .catch(error => {
                    console.error('Generation error:', error);
                    messageDiv.innerHTML = '<span style="color: #f44336;">‚úó Error: ' + error.message + '</span>';
                    button.disabled = false;
                    button.textContent = 'Generate New Puzzle';
                });
        }

        function highlightSameNumbersAndRowCol(selectedCell, number) {
            clearHighlights();
            if (!selectedCell) return;

            // Get row and col
            let row = null, col = null;
            if (selectedCell.tagName === 'INPUT') {
                row = parseInt(selectedCell.dataset.row);
                col = parseInt(selectedCell.dataset.col);
            } else {
                row = parseInt(selectedCell.getAttribute('data-row'));
                col = parseInt(selectedCell.getAttribute('data-col'));
            }

            // Highlight row and column
            document.querySelectorAll('.sudoku td').forEach(cell => {
                const cellRow = parseInt(cell.getAttribute('data-row'));
                const cellCol = parseInt(cell.getAttribute('data-col'));
                if (cellRow === row || cellCol === col) {
                    cell.classList.add('rowcol-highlight');
                }
            });

            // Highlight selected cell
            if (selectedCell.tagName === 'INPUT') {
                selectedCell.parentElement.classList.add('selected-cell');
            } else {
                selectedCell.classList.add('selected-cell');
            }

            // Highlight all cells with the same number
            document.querySelectorAll('.sudoku td').forEach(cell => {
                const text = cell.textContent.trim();
                const input = cell.querySelector('input');
                if (text === number && cell.classList.contains('prefilled')) {
                    cell.classList.add('highlighted-prefilled');
                } else if (input && input.value === number && input.value !== '' && !cell.classList.contains('prefilled')) {
                    cell.classList.add('highlighted-user');
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.sudoku td').forEach(cell => {
                cell.classList.remove('highlighted', 'highlighted-prefilled', 'highlighted-user', 'rowcol-highlight', 'selected-cell');
            });
        }
    </script>
</body>
</html>
