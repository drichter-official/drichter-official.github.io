<!DOCTYPE html>
<html>
<head>
    <title>Door {{door}} - Interactive Sudoku</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .sudoku-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .sudoku {
            border-collapse: separate;
            border-spacing: 0;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 3px solid #000000 !important;        /* Thick outer border */
        }
        .sudoku td {
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            position: relative;
            box-sizing: border-box;
            border-top: 1px solid #bbb;        /* Thin default grid line */
            border-left: 1px solid #bbb;
            border-right: 0;
            border-bottom: 0;
        }
        /* Remove top border for first row (leave for table) */
        .sudoku tr:first-child td {
            border-top: none;
        }
        /* Remove left border for first column (leave for table) */
        .sudoku td:first-child {
            border-left: none;
        }
        /* Thick top borders after rows 3 and 6 (for box separators) */
        .sudoku tr:nth-child(4) td,
        .sudoku tr:nth-child(7) td {
            border-top: 2px solid #000;
        }
        /* Thick left borders after columns 3 and 6 (for box separators) */
        .sudoku td:nth-child(4),
        .sudoku td:nth-child(7) {
            border-left: 2px solid #000;
        }
        /* No bottom border for last row (table border only) */
        .sudoku tr:last-child td {
            border-bottom: none;
        }
        /* No right border for last column (table border only) */
        .sudoku td:last-child {
            border-right: none;
        }
        .sudoku td input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: 1.3rem;
            font-weight: bold;
            outline: none;
            background-color: #fffef0;
        }

        /* Remove browser focus outline/shadow and hide the blinking caret when an input is focused
           This removes the blue blinking line on focused inputs while preserving the selected-cell
           outline which is applied to the parent <td>. */
        .sudoku td input:focus {
            outline: none !important;
            box-shadow: none !important;
            -webkit-box-shadow: none !important;
            -webkit-appearance: none !important;
            caret-color: transparent !important; /* hides blinking caret */
            -webkit-tap-highlight-color: transparent !important; /* mobile tap highlight */
        }

        /* Layer 1: Base background - LOWEST PRIORITY */
        /* Default input background is set above */

        /* Layer 2: Prefilled cells - overrides background, borders show through */
        .sudoku td.prefilled {
            background-color: #e8e8e8;
            color: inherit;
            cursor: pointer;
        }
        .sudoku td.prefilled:focus {
            outline: none; /* Remove default outline, we use selected-cell class */
        }

        /* Layer 3: Special field colors - override prefilled cells, borders show through */
        .sudoku td.diagonal-cell {
            background-color: #e8f4f8 !important;
            color: inherit;
        }
        .sudoku td.windoku-cell {
            background-color: #e3f2fd !important;
            color: inherit;
        }
        .sudoku td.asterisk-cell {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.even-cell {
            background-color: #c8e6c9 !important;
            color: inherit;
        }
        .sudoku td.odd-cell {
            background-color: #ffccbc !important;
            color: inherit;
        }
        .sudoku td.magic-square-cell {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.center-dot-cell {
            background-color: #ffe0b2 !important;
            color: inherit;
        }
        .sudoku td.thermo-cell {
            background-color: #e1f5fe !important;
            color: inherit;
        }
        .sudoku td.arrow-circle {
            background-color: #fff9c4 !important;
            color: inherit;
            border-radius: 50%;
        }
        .sudoku td.arrow-cell {
            background-color: #fffde7 !important;
            color: inherit;
        }
        .sudoku td.renban-cell {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-0 {
            background-color: #ffebee !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-1 {
            background-color: #e8f5e9 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-2 {
            background-color: #e3f2fd !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-3 {
            background-color: #fff3e0 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-4 {
            background-color: #f3e5f5 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-5 {
            background-color: #fce4ec !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-6 {
            background-color: #e0f2f1 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-7 {
            background-color: #fff9c4 !important;
            color: inherit;
        }
        .sudoku td.jigsaw-region-8 {
            background-color: #e1f5fe !important;
            color: inherit;
        }
        .sudoku td.whisper-cell {
            background-color: #e1bee7 !important;
            color: inherit;
        }
        .sudoku td.chain-corner-cell {
            background-color: #ffecb3 !important;
            color: inherit;
        }
        .sudoku td.consecutive-cell {
            background-color: #c5e1a5 !important;
            color: inherit;
        }
        .sudoku td.argyle-cell {
            background-color: #d1c4e9 !important;
            color: inherit;
        }
        .sudoku td.star-cell {
            background-color: #fff59d !important;
            color: inherit;
        }
        .sudoku td.killer-cage {
            border-style: dashed;
            border-width: 2px;
            border-color: #9c27b0 !important;
        }

        .sudoku td.cage-sum {
            font-size: 0.7rem;
            color: #9c27b0;
            position: absolute;
            top: 2px;
            left: 2px;
            font-weight: normal;
        }

        /* Make all special field inputs transparent so background shows through */
        .sudoku td.diagonal-cell input,
        .sudoku td.windoku-cell input,
        .sudoku td.asterisk-cell input,
        .sudoku td.even-cell input,
        .sudoku td.odd-cell input,
        .sudoku td.magic-square-cell input,
        .sudoku td.center-dot-cell input,
        .sudoku td.thermo-cell input,
        .sudoku td.arrow-circle input,
        .sudoku td.arrow-cell input,
        .sudoku td.renban-cell input,
        .sudoku td.whisper-cell input,
        .sudoku td.chain-corner-cell input,
        .sudoku td.consecutive-cell input,
        .sudoku td.argyle-cell input,
        .sudoku td.star-cell input,
        .sudoku td.jigsaw-region-0 input,
        .sudoku td.jigsaw-region-1 input,
        .sudoku td.jigsaw-region-2 input,
        .sudoku td.jigsaw-region-3 input,
        .sudoku td.jigsaw-region-4 input,
        .sudoku td.jigsaw-region-5 input,
        .sudoku td.jigsaw-region-6 input,
        .sudoku td.jigsaw-region-7 input,
        .sudoku td.jigsaw-region-8 input,
        .sudoku td.jigsaw-region-9 input

        {
            background-color: transparent;
        }
        /* Layer 4: Interactive highlights - override special field colors */
        .sudoku td.rowcol-highlight {
            background-color: #f3e5f5 !important; /* very light blue for row/col */
            color: inherit;
        }
        .sudoku td.highlighted-user {
            background-color: #ce93d8 !important; /* purple for user-filled same number */
            color: inherit;
        }
        .sudoku td.highlighted-prefilled {
            background-color: #b995f0 !important; /* darker purple for prefilled same number */
            color: inherit;
        }
        .sudoku td.rowcol-highlight input,
        .sudoku td.highlighted-user input,
        .sudoku td.highlighted-prefilled input {
            background-color: transparent;
        }

        /* Selected cell outline - doesn't change background */
        .sudoku td.selected-cell {
            outline: 2px solid #b995f0;
            outline-offset: -2px;
            z-index: 10;
            position: relative;
        }

        /* Layer 5: Validation colors - HIGHEST PRIORITY - override everything */
        .sudoku td.correct {
            background-color: #a5d6a7 !important;
            color: inherit;
        }
        .sudoku td.correct input {
            background-color: transparent;
        }
        .sudoku td.incorrect {
            background-color: #ef9a9a !important;
            color: inherit;
        }
        .sudoku td.incorrect input {
            background-color: transparent;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            font-size: 1rem;
            margin: 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        #message {
            text-align: center;
            margin: 20px 0;
            padding: 10px;
            font-size: 1.1rem;
            font-weight: bold;
        }
        .success {
            color: #4CAF50;
        }
        .error {
            color: #f44336;
        }
        .back-link {
            display: block;
            text-align: center;
            margin: 20px 0;
            text-decoration: none;
            color: #2196F3;
            font-size: 1rem;
        }
        .back-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Day {{ door }} - {{ metadata.rule.name }}</h1>
    <p style="text-align: center;">{{ metadata.rule.description }}</p>

    <div class="sudoku-container">
        <table class="sudoku" id="sudokuGrid">
            {% for i in range(9) %}
            <tr>
                {% for j in range(9) %}
                <td class="{{ 'prefilled' if sudoku[i][j] != 0 else '' }}" data-row="{{i}}" data-col="{{j}}" {% if sudoku[i][j] != 0 %}tabindex="0"{% endif %}>
                    {% if sudoku[i][j] != 0 %}
                        {{ sudoku[i][j] }}
                    {% else %}
                        <input type="text" maxlength="1" data-row="{{i}}" data-col="{{j}}" />
                    {% endif %}
                </td>
                {% endfor %}
            </tr>
            {% endfor %}
        </table>
    </div>

    <div class="controls">
        <button onclick="checkSolution()">Check Solution</button>
        <button onclick="clearAll()" class="secondary">Clear All</button>
        <button onclick="resetBoard()" class="secondary">Reset</button>
        <button onclick="generateNewPuzzle()" class="secondary">Generate New Puzzle</button>
    </div>

    <div id="message"></div>
    <div id="generation-message" style="text-align: center; margin: 10px 0; padding: 10px; font-size: 1rem;"></div>

    <a href="/" class="back-link">‚Üê Back to Calendar</a>

    <script>
        // Store the solution and metadata
        const solution = {{ solution | tojson }};
        const initialPuzzle = {{ sudoku | tojson }};
        const metadata = {{ metadata | tojson }};

        // Apply special cell highlighting based on metadata
        function applySpecialCellHighlighting() {
            const rule = metadata.rule;

            // Diagonal cells (Diagonal Rule)
            if (rule.diagonal_cells) {
                rule.diagonal_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('diagonal-cell');
                });
            } else if (rule.name && rule.name.includes('Diagonal')) {
                // Fallback for old metadata without diagonal_cells
                for (let i = 0; i < 9; i++) {
                    // Main diagonal
                    const cell1 = document.querySelector(`td[data-row="${i}"][data-col="${i}"]`);
                    if (cell1) cell1.classList.add('diagonal-cell');

                    // Anti-diagonal
                    const cell2 = document.querySelector(`td[data-row="${i}"][data-col="${8-i}"]`);
                    if (cell2) cell2.classList.add('diagonal-cell');
                }
            }

            // Windoku regions
            if (rule.windoku_regions) {
                rule.windoku_regions.forEach(region => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('windoku-cell');
                    });
                });
            }

            // Asterisk cells
            if (rule.asterisk_cells) {
                rule.asterisk_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('asterisk-cell');
                });
            }

            // Even cells
            if (rule.even_cells) {
                rule.even_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('even-cell');
                });
            }

            // Odd cells
            if (rule.odd_cells) {
                rule.odd_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('odd-cell');
                });
            }

            // Magic Square cells
            if (rule.magic_box_location) {
                const loc = rule.magic_box_location;
                loc.rows.forEach(row => {
                    loc.cols.forEach(col => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('magic-square-cell');
                    });
                });
            }

            // Center Dot cells (center of each 3x3 box)
            if (rule.center_dot_cells) {
                rule.center_dot_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('center-dot-cell');
                });
            } else if (rule.name && rule.name.includes('Center Dot')) {
                // Fallback for old metadata without center_dot_cells
                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        const centerRow = boxRow * 3 + 1;
                        const centerCol = boxCol * 3 + 1;
                        const cell = document.querySelector(`td[data-row="${centerRow}"][data-col="${centerCol}"]`);
                        if (cell) cell.classList.add('center-dot-cell');
                    }
                }
            }

            // Killer Sudoku cages
            if (rule.cages) {
                rule.cages.forEach((cage, index) => {
                    cage.cells.forEach(([row, col], cellIndex) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.classList.add('killer-cage');
                            // Add sum label to first cell in cage
                            if (cellIndex === 0) {
                                const sumLabel = document.createElement('div');
                                sumLabel.className = 'cage-sum';
                                sumLabel.textContent = cage.sum;
                                cell.insertBefore(sumLabel, cell.firstChild);
                            }
                        }
                    });
                });
            }

            // Thermometer cells
            if (rule.thermometers) {
                rule.thermometers.forEach(thermo => {
                    thermo.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('thermo-cell');
                    });
                });
            }

            // Arrow Sudoku
            if (rule.arrows) {
                rule.arrows.forEach(arrow => {
                    // Circle cell
                    const [circleRow, circleCol] = arrow.circle;
                    const circleCell = document.querySelector(`td[data-row="${circleRow}"][data-col="${circleCol}"]`);
                    if (circleCell) circleCell.classList.add('arrow-circle');

                    // Arrow cells
                    arrow.arrow_cells.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('arrow-cell');
                    });
                });
            }

            // Renban lines
            if (rule.renban_lines) {
                rule.renban_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('renban-cell');
                    });
                });
            }

            // Jigsaw regions
            if (rule.jigsaw_regions) {
                rule.jigsaw_regions.forEach((region, regionIndex) => {
                    region.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add(`jigsaw-region-${regionIndex}`);
                    });
                });
            }

            // Whisper lines
            if (rule.whisper_lines) {
                rule.whisper_lines.forEach(line => {
                    line.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('whisper-cell');
                    });
                });
            }

            // Chain Sudoku corner cells
            if (rule.corner_cells) {
                rule.corner_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('chain-corner-cell');
                });
            }

            // Consecutive pairs
            if (rule.consecutive_pairs) {
                rule.consecutive_pairs.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) cell.classList.add('consecutive-cell');
                    });
                });
            }

            // Argyle cells (diagonals within boxes)
            if (rule.argyle_cells) {
                rule.argyle_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('argyle-cell');
                });
            }

            // Star pattern cells
            if (rule.star_cells) {
                rule.star_cells.forEach(([row, col]) => {
                    const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                    if (cell) cell.classList.add('star-cell');
                });
            }

            // XV pairs - mark cells involved in X or V constraints
            if (rule.x_pairs) {
                rule.x_pairs.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            // Add a visual indicator for XV constraints
                            cell.style.borderColor = '#ff6b6b';
                            cell.style.borderWidth = '2px';
                        }
                    });
                });
            }

            if (rule.v_pairs) {
                rule.v_pairs.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            // Add a visual indicator for XV constraints
                            cell.style.borderColor = '#4ecdc4';
                            cell.style.borderWidth = '2px';
                        }
                    });
                });
            }

            // Futoshiki inequalities - draw inequality symbols
            if (rule.inequalities) {
                rule.inequalities.forEach(inequality => {
                    const [r1, c1] = inequality.cell1;
                    const [r2, c2] = inequality.cell2;
                    const operator = inequality.operator;
                    
                    // Add visual styling to cells involved in inequalities
                    const cell1 = document.querySelector(`td[data-row="${r1}"][data-col="${c1}"]`);
                    const cell2 = document.querySelector(`td[data-row="${r2}"][data-col="${c2}"]`);
                    if (cell1) cell1.style.borderColor = '#9c27b0';
                    if (cell2) cell2.style.borderColor = '#9c27b0';
                    
                    // TODO: Draw inequality symbols between cells
                });
            }

            // Kropki dots - mark cells with white or black dots
            if (rule.white_dots) {
                rule.white_dots.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.style.borderColor = '#ffffff';
                            cell.style.borderWidth = '2px';
                        }
                    });
                });
            }

            if (rule.black_dots) {
                rule.black_dots.forEach(pair => {
                    pair.forEach(([row, col]) => {
                        const cell = document.querySelector(`td[data-row="${row}"][data-col="${col}"]`);
                        if (cell) {
                            cell.style.borderColor = '#000000';
                            cell.style.borderWidth = '3px';
                        }
                    });
                });
            }
        }

        // Apply highlighting when page loads
        document.addEventListener('DOMContentLoaded', function() {
            applySpecialCellHighlighting();
        });

        // Only allow numbers 1-9
        document.querySelectorAll('.sudoku input').forEach(input => {
            input.addEventListener('input', function(e) {
                const value = e.target.value;
                if (value && (!/^[1-9]$/.test(value))) {
                    e.target.value = '';
                } else {
                    highlightSameNumbersAndRowCol(e.target, value);
                }
            });

            input.addEventListener('focus', function(e) {
                const value = e.target.value;
                highlightSameNumbersAndRowCol(e.target, value);
            });

            input.addEventListener('blur', function(e) {
                clearHighlights();
            });

            // Add keyboard navigation
            input.addEventListener('keydown', function(e) {
                handleKeyboardNavigation(e, e.target);
            });
        });

        // Add click, focus, blur and keyboard navigation listeners to prefilled cells
        document.querySelectorAll('.sudoku td.prefilled').forEach(cell => {
            cell.addEventListener('click', function(e) {
                cell.focus();
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });

            cell.addEventListener('focus', function(e) {
                const value = e.target.textContent.trim();
                highlightSameNumbersAndRowCol(cell, value);
            });

            cell.addEventListener('blur', function(e) {
                clearHighlights();
            });

            cell.addEventListener('keydown', function(e) {
                handleKeyboardNavigation(e, cell);
            });
        });

        // Unified keyboard navigation handler
        function handleKeyboardNavigation(e, element) {
            let row, col;
            if (element.tagName === 'INPUT') {
                row = parseInt(element.dataset.row);
                col = parseInt(element.dataset.col);
            } else {
                row = parseInt(element.getAttribute('data-row'));
                col = parseInt(element.getAttribute('data-col'));
            }

            let newRow = row;
            let newCol = col;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    newRow = row > 0 ? row - 1 : row;
                    break;
                case 'ArrowDown':
                case 'Enter':
                    e.preventDefault();
                    newRow = row < 8 ? row + 1 : row;
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    newCol = col > 0 ? col - 1 : col;
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    newCol = col < 8 ? col + 1 : col;
                    break;
                default:
                    return; // Don't navigate for other keys
            }

            if (newRow !== row || newCol !== col) {
                // Try to find input first, then prefilled cell
                let nextCell = document.querySelector(`input[data-row="${newRow}"][data-col="${newCol}"]`);
                if (nextCell) {
                    nextCell.focus();
                    nextCell.select();
                } else {
                    nextCell = document.querySelector(`td[data-row="${newRow}"][data-col="${newCol}"].prefilled`);
                    if (nextCell) {
                        nextCell.focus();
                    }
                }
            }
        }

        // Clear highlights when clicking outside the sudoku grid
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.sudoku')) {
                clearHighlights();
            }
        });

        function checkSolution() {
            let allCorrect = true;
            let allFilled = true;
            const inputs = document.querySelectorAll('.sudoku input');

            inputs.forEach(input => {
                const row = parseInt(input.dataset.row);
                const col = parseInt(input.dataset.col);
                const value = input.value;
                const cell = input.parentElement;

                // Remove previous styling
                cell.classList.remove('correct', 'incorrect');

                if (!value) {
                    allFilled = false;
                    return;
                }

                if (parseInt(value) === solution[row][col]) {
                    cell.classList.add('correct');
                } else {
                    cell.classList.add('incorrect');
                    allCorrect = false;
                }
            });

            const messageDiv = document.getElementById('message');
            if (!allFilled) {
                messageDiv.innerHTML = '<span class="error">Please fill in all cells first!</span>';
            } else if (allCorrect) {
                messageDiv.innerHTML = '<span class="success">üéâ Congratulations! You solved the Sudoku correctly! üéâ</span>';
            } else {
                messageDiv.innerHTML = '<span class="error">Some cells are incorrect. Keep trying!</span>';
            }
        }

        function clearAll() {
            document.querySelectorAll('.sudoku input').forEach(input => {
                input.value = '';
                input.parentElement.classList.remove('correct', 'incorrect');
            });
            document.getElementById('message').innerHTML = '';
        }

        function resetBoard() {
            clearAll();
        }

        function generateNewPuzzle() {
            const messageDiv = document.getElementById('generation-message');
            const doorNumber = {{ door }};

            // Disable button and show loading message
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';
            messageDiv.innerHTML = '<span style="color: #2196F3;">Generating new puzzle... This may take a moment.</span>';

            // Call the Flask route to generate a new puzzle
            fetch(`/generate/${doorNumber}`)
                .then(response => {
                    // Check if response is JSON
                    const contentType = response.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        throw new Error('Server returned non-JSON response. This may be a permissions issue on the server.');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        messageDiv.innerHTML = '<span style="color: #4CAF50;">‚úì ' + data.message + ' Reloading...</span>';
                        // Reload the page after a short delay to show the new puzzle
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        messageDiv.innerHTML = '<span style="color: #f44336;">‚úó ' + data.message + '</span>';
                        button.disabled = false;
                        button.textContent = 'Generate New Puzzle';
                    }
                })
                .catch(error => {
                    console.error('Generation error:', error);
                    messageDiv.innerHTML = '<span style="color: #f44336;">‚úó Error: ' + error.message + '</span>';
                    button.disabled = false;
                    button.textContent = 'Generate New Puzzle';
                });
        }

        function highlightSameNumbersAndRowCol(selectedCell, number) {
            clearHighlights();
            if (!selectedCell) return;

            // Get row and col
            let row = null, col = null;
            if (selectedCell.tagName === 'INPUT') {
                row = parseInt(selectedCell.dataset.row);
                col = parseInt(selectedCell.dataset.col);
            } else {
                row = parseInt(selectedCell.getAttribute('data-row'));
                col = parseInt(selectedCell.getAttribute('data-col'));
            }

            // Highlight row and column
            document.querySelectorAll('.sudoku td').forEach(cell => {
                const cellRow = parseInt(cell.getAttribute('data-row'));
                const cellCol = parseInt(cell.getAttribute('data-col'));
                if (cellRow === row || cellCol === col) {
                    cell.classList.add('rowcol-highlight');
                }
            });

            // Highlight selected cell
            if (selectedCell.tagName === 'INPUT') {
                selectedCell.parentElement.classList.add('selected-cell');
            } else {
                selectedCell.classList.add('selected-cell');
            }

            // Highlight all cells with the same number
            document.querySelectorAll('.sudoku td').forEach(cell => {
                const text = cell.textContent.trim();
                const input = cell.querySelector('input');
                if (text === number && cell.classList.contains('prefilled')) {
                    cell.classList.add('highlighted-prefilled');
                } else if (input && input.value === number && input.value !== '' && !cell.classList.contains('prefilled')) {
                    cell.classList.add('highlighted-user');
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.sudoku td').forEach(cell => {
                cell.classList.remove('highlighted', 'highlighted-prefilled', 'highlighted-user', 'rowcol-highlight', 'selected-cell');
            });
        }
    </script>
</body>
</html>
